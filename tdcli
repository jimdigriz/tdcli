#!/usr/bin/env perl

use strict;
use warnings;

use v5.14;

use File::stat;
use Fcntl qw(:mode);
use Config::Tiny;
use WWW::Mechanize;
use HTTP::Status qw(is_client_error is_server_error);
use URI;
use JSON;
use Getopt::Std;
use Time::Piece;
use Date::Calc qw(Today Delta_Days Add_Delta_YMD);
use Text::CSV;

use Data::Dumper;

my $VERSION = '0.1';

use constant URL_BASE	=> 'https://secure.tddirectinvesting.co.uk/webbroker2';
use constant URL_LOGIN	=> '/login.jsp';
use constant URL_STEPUP	=> '/displayStepUpQuestion.sp';
use constant URL_INFO	=> '/customers/%USERACCT%/accountsInfo.sp';
use constant URL_PORT	=> '/customers/%USERACCT%/accounts/%ACCT%/portfolio-holdings.sp';
use constant URL_TRAN	=> '/customers/%USERACCT%/account/%ACCT%/transactions/GBP.sp';

my %opts;
getopts('PTa:f:t:', \%opts);

$opts{f} = substr(localtime->ymd, 0, 8) . '01'
	unless (defined($opts{f}));
die 'from date must be of the format YYYY-MM-DD'
	unless ($opts{f} =~ /^[0-9]{4}-[01][0-9]-[0-3][0-9]$/);
$opts{f} = [ split(/-/, $opts{f}, 3) ];

$opts{t} = localtime->ymd
	unless (defined($opts{t}));
die 'to date must be of the format YYYY-MM-DD'
	unless ($opts{t} =~ /^[0-9]{4}-[01][0-9]-[0-3][0-9]$/);
$opts{t} = [ split(/-/, $opts{t}, 3) ];

die 'to date is in the future'
	unless (Delta_Days(@{$opts{t}}, Today()) >= 0);

die 'from date is later than to date'
	unless (Delta_Days(@{$opts{f}}, @{$opts{t}}) >= 0);

mkdir "$ENV{HOME}/.tdcli"
	unless (-d "$ENV{HOME}/.tdcli");
chmod 0700, "$ENV{HOME}/.tdcli";

die '~/.tdcli/config does not exist'
	unless (-f "$ENV{HOME}/.tdcli/config");

my $mode = stat("$ENV{HOME}/.tdcli/config")->mode;
if (($mode & S_IRGRP) && ($mode & S_IROTH)) {
	warn '~/.tdcli/config is not chmod 0600, fixing';
	chmod 0600, "$ENV{HOME}/.tdcli/config";
}

my $cfg = Config::Tiny->read("$ENV{HOME}/.tdcli/config")
	or die 'unable to open config: ' . Config::Tiny->errstr;

die 'missing user/pass attributes in ~/.tdcli/config'
	unless (defined($cfg->{_}->{user}) && defined($cfg->{_}->{pass}));

my $mech = WWW::Mechanize->new;
$mech->timeout(10);
$mech->env_proxy;
$mech->agent("tdcli/$VERSION (+https://github.com/jimdigriz/tdcli; " . $mech->_agent . ')');
$mech->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
$mech->from($cfg->{_}->{from})
	if (defined($cfg->{_}->{from}));

if (defined($cfg->{'_'}->{'debug'}) && $cfg->{'_'}->{'debug'} == 1) {
	warn 'debugging enabled, you will see the HTTPS requests in the clear!';
	&debug($mech);
}

$mech->cookie_jar({file => "$ENV{HOME}/.tdcli/cookies.txt", autosave => 1, ignore_discard => 1});
chmod 0600, "$ENV{HOME}/.tdcli/cookies.txt";

my $csrftoken;
if (-f "$ENV{HOME}/.tdcli/csrftoken" && open(my $T, '<', "$ENV{HOME}/.tdcli/csrftoken")) {
	local $/;
	$csrftoken = <$T>;
}
unlink "$ENV{HOME}/.tdcli/csrftoken";

my %accts;
($cfg->{_}->{'acct'}, $csrftoken, %accts) = &login($csrftoken);

# TODO only write when changed
$cfg->write("$ENV{HOME}/.tdcli/config");
chmod 0600, "$ENV{HOME}/.tdcli/config";

# TODO only write when changed
open my $T, '>', "$ENV{HOME}/.tdcli/csrftoken";
chmod 0600, "$ENV{HOME}/.tdcli/csrftoken";
print $T $csrftoken;
close $T;

unless (defined($opts{P}) || defined($opts{T})) {
	print "Accounts (${\$cfg->{_}->{'acct'}}):\n";
	printf " * %s {%s}: %s\n", $_, $accts{$_}{type}, $accts{$_}{description}
		foreach (keys %accts);
	exit 0;
}

die 'need to supply valid account id'
	unless (defined($opts{a}) && defined($accts{$opts{a}}));

my $csv = Text::CSV->new;
$csv->eol("\r\n");

my %fields;
my @data;
if ($opts{P}) {
	my $j = &fetchJSON($opts{a}, URL_BASE . URL_PORT);

	@data = @{$j->{portfolios}->{ALL}};
	%fields = map { $_, 1 } map { keys $_ } @data;
} elsif ($opts{T}) {
	my @f = @{$opts{f}};
	my @t = Add_Delta_YMD(@f, 0, 18, 0);
	while (Delta_Days(@f, @{$opts{t}}) >= 0) {
		@t = @{$opts{t}}
			unless (Delta_Days(@t, @{$opts{t}}) >= 0);

		my $j = &fetchJSON($opts{a}, URL_BASE . URL_TRAN,
				fromDate => join('/', reverse @f), toDate => join('/', reverse @t));

		push @data, @{$j->{statementLines}};

		@f = Add_Delta_YMD(@f, 0, 18, 0);
		@t = Add_Delta_YMD(@f, 0, 18, 0);
	}

	%fields = map { $_, 1 } map { keys $_ } @data;

	for (my $i = 0; $i < @data; $i++) {
		$data[$i]{symbol} = 'LON:' . $data[$i]{symbol}
			if (defined($data[$i]{symbol}) && $data[$i]{symbol} ne '');
		$data[$i]{price} *= 100
			if (defined($data[$i]{price}));
	}
}

$csv->print(\*STDOUT, [ keys %fields ]);
foreach my $d (@data) {
	$csv->print(\*STDOUT, [ map { $d->{$_} } keys %fields ]);
}

exit 0;

sub HELP_MESSAGE {
	print <<EOT;
Usage: tdcli [ -a 1234 [ -P | -T [ -f YYYY-MM-DD ] [ -t YYYY-MM-DD ] ] ]
Pull data from your TD Direct Investing account.

  -a ID                    select account number
  -P                       output CSV of portfolio
  -T                       output CSV of transactions
  -f YYYY-MM-DD            from date (default: 1st of current month)
  -t YYYY-MM-DD            to date (default: today)
EOT

	exit 0;
}

sub debug {
	my ($m) = @_;

       	$m->add_handler('request_send',  sub { my $r = $_[0]->clone; $r->decode; print STDERR "$_\n" foreach split /\n/, $r->dump });
       	$m->add_handler('response_done', sub { my $r = $_[0]->clone; $r->decode; print STDERR "$_\n" foreach split /\n/, $r->dump });
}

sub login {
	if (defined($cfg->{_}->{'acct'}) && defined($csrftoken)) {
		my $info = &fetchJSON(0, URL_BASE . URL_INFO);

		my %accts;
		$accts{$_->{accountId}} = $_
			foreach (@{$info->{accounts}});

		return ($cfg->{_}->{'acct'}, $csrftoken, %accts)
			if (defined($info));
	}

	my $m = $mech->clone;

	&debug($m)
		if (defined($cfg->{'_'}->{'debug'}) && $cfg->{'_'}->{'debug'} == 1);

	# deal with unsupported browser
	$m->agent('Mozilla/5.0 (X11; Linux x86_64; rv:36.0) Gecko/20100101 Firefox/36.0 Iceweasel/36.0.4');

	my $r = $m->get(URL_BASE . URL_LOGIN);
	die 'unable to fetch login page: ' . $r->status_line
		if (is_server_error($r->code));

	die 'not allowed to fetch login page: ' . $r->status_line
		if (is_client_error($r->code));

	my $f = $m->form_name('logon');
	die "'login' form not found"
		unless (defined($f));

	$m->field('username', $cfg->{_}->{user});
	my $pass = '';
	for my $p ('first', 'second', 'third') {
		my $l = substr $cfg->{_}->{pass}, $f->find_input("${p}Challenge")->value - 1, 1;

		$m->field("${p}Response", $l);
		$pass .= $l;
	}
	$m->field('password', $pass);
	$m->field('deviceFingerprint', '{"tz":0,"local":false,"session":false,"global":false,"user":false,"db":false}');

	$r = $m->click;
	die 'unable to login: ' . $r->status_line
		if (is_server_error($r->code));

	die 'login failed: ' . $r->status_line
		if (is_client_error($r->code));

	if ($m->uri eq URL_BASE . URL_STEPUP) {
		$r->decoded_content =~ /<form .*name="secQuestions".*What is your memorable ([\w]+)\?.*<\/form>/ms;

		$m->form_name('secQuestions');
		$m->field('answer', $cfg->{stepup}->{$1});

		$r = $m->click;
		die 'unable to stepup: ' . $r->status_line
			if (is_server_error($r->code));

		die 'stepup failed: ' . $r->status_line
			if (is_client_error($r->code));
	}

	my $link = $m->find_link(tag => 'frame', name => 'contentFrame');
	die 'unable to parse logged in page'
		unless (defined($link));

	my $uri = URI->new($link->URI->fragment);
	my $useracct = ($uri->path_segments)[2];
	die 'cannot find user account id'
		unless (defined($useracct));

	my %query = map { split /=/, $uri->query, 2 } split /&/, $uri->query, 2;
	die 'cannot find CSRFTOKEN'
		unless (defined($query{CSRFTOKEN}));

	my $info = &fetchJSON(0, URL_BASE . URL_INFO, CSRFTOKEN => $query{CSRFTOKEN});

	my %accts;
	$accts{$_->{accountId}} = $_
		foreach (@{$info->{accounts}});

	return ($cfg->{_}->{'acct'}, $query{CSRFTOKEN}, %accts)
}

sub fetchJSON {
	my ($acct, $url, %qs) = @_;

	my $m = $mech->clone;

	&debug($m)
		if (defined($cfg->{'_'}->{'debug'}) && $cfg->{'_'}->{'debug'} == 1);

	$url =~ s/%USERACCT%/$cfg->{_}->{'acct'}/g;
	$url =~ s/%ACCT%/$acct/g;

	my $uri = URI->new($url);
	$qs{CSRFTOKEN} = $csrftoken
		if (defined($csrftoken));
	$uri->query_form(%qs);

	my $r = $m->get($uri);
	die 'unable to fetch info page: ' . $r->status_line
		if (is_server_error($r->code));

	die 'not allowed to fetch info page: ' . $r->status_line
		if (is_client_error($r->code));

	return if ($m->uri =~ /\/error-pages\//);

	my $json = from_json $r->decoded_content;

	die 'unable to parse JSON'
		unless (defined($json));

	return $json;
}
